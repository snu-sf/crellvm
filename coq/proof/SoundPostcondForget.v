(* Require Import syntax. *)
(* Require Import alist. *)
(* Require Import FMapWeakList. *)

(* Require Import Classical. *)
(* Require Import Coqlib. *)
(* Require Import infrastructure. *)
(* Require Import Metatheory. *)
(* Import LLVMsyntax. *)
(* Import LLVMinfra. *)
(* Require Import opsem. *)

(* Require Import sflib. *)
(* Require Import paco. *)
(* Import Opsem. *)

(* Require Import TODO. *)
(* Require Import Exprs. *)
(* Require Import Hints. *)
(* Require Import Postcond. *)
(* Require Import Validator. *)
(* Require Import GenericValues. *)
(* Require InvMem. *)
(* Require InvState. *)
(* Require Import Inject. *)
(* Require Import SoundBase. *)
(* Require Import SoundForget. *)

(* Set Implicit Arguments. *)


(* (* TODO: move this *) *)
(* Lemma AtomSetImpl_from_list_spec1 x l *)
(*   : AtomSetImpl.In x (AtomSetImpl_from_list l) <-> In x l. *)
(* Proof. *)
(* Admitted. *)

(* Lemma AtomSetImpl_from_list_spec2 x l *)
(*   : ~ AtomSetImpl.In x (AtomSetImpl_from_list l) <-> ~ In x l. *)
(* Proof. *)
(* Admitted. *)

(* Ltac singleton_neq := *)
(*   match goal with *)
(*   | [NOT_MEM: AtomSetImpl.mem ?x (AtomSetImpl_from_list [?y]) = false |- _] => *)
(*     apply AtomSetFacts.not_mem_iff in NOT_MEM; *)
(*     apply AtomSetImpl_from_list_spec2 in NOT_MEM; *)
(*     apply elim_not_In_cons in NOT_MEM; des; *)
(*     apply lookupAL_updateAddAL_neq; eauto *)
(*   end. *)

(* Lemma step_state_equiv_except *)
(*       cmd cmds *)
(*       conf st0 st1 evt *)
(*       (CMDS: st0.(EC).(CurCmds) = cmd :: cmds) *)
(*       (NONCALL: Instruction.isCallInst cmd = false) *)
(*       (STEP: sInsn conf st0 st1 evt) *)
(*   : state_equiv_except (AtomSetImpl_from_list (option_to_list (Cmd.get_def cmd))) st0 st1. *)
(* Proof. *)
(*   inv STEP; ss; *)
(*     try (inv CMDS; ss; *)
(*          econs; ss; ii; *)
(*          singleton_neq). *)
(*   - admit. (* malloc *) (* inv CMDS. econs; ss. *) *)
(*   - admit. (* free *) *)
(*   - admit. (* alloca *) *)
(*   - admit. (* store *) *)
(* Admitted. *)

(* Lemma step_unique_preserved_except *)
(*       st0 st1 cmd cmds evt *)
(*       conf invst0 inv0 *)
(*       (UNIQUE: AtomSetImpl.For_all (InvState.Unary.sem_unique conf st0 invst0) inv0.(Invariant.unique)) *)
(*       (CMDS: st0.(EC).(CurCmds) = cmd :: cmds) *)
(*       (NONCALL: Instruction.isCallInst cmd = false) *)
(*       (STEP: sInsn conf st0 st1 evt) *)
(*   : SoundForget.unique_preserved_except conf invst0 inv0 st1 *)
(*                                         (AtomSetImpl_from_list (Cmd.get_def cmd)) (AtomSetImpl_from_list (Cmd.get_leaked_ids cmd)). *)
(* Proof. *)
(* Admitted. *)

(* Definition FORGET_MEMORY_TODO: Prop. Admitted. (* TODO *) *)

(* Lemma postcond_cmd_forget_sound *)
(*       conf_src st0_src st1_src def_src leaks_src def_memory_src *)
(*       conf_tgt st0_tgt st1_tgt def_tgt leaks_tgt def_memory_tgt *)
(*       invst0 invmem0 inv0 *)
(*       (STATE: InvState.Rel.sem conf_src conf_tgt st0_src st0_tgt invst0 invmem0 inv0) *)
(*       (MEM: InvMem.Rel.sem conf_src conf_tgt st0_src.(Mem) st0_tgt.(Mem) invmem0) *)
(*       (STATE_SRC: state_equiv_except def_src st0_src st1_src) *)
(*       (STATE_TGT: state_equiv_except def_tgt st0_tgt st1_tgt) *)
(*       (UNIQUE_SRC: unique_preserved_except conf_src invst0.(InvState.Rel.src) inv0.(Invariant.src) st1_src def_src leaks_src) *)
(*       (UNIQUE_TGT: unique_preserved_except conf_tgt invst0.(InvState.Rel.tgt) inv0.(Invariant.tgt) st1_tgt def_tgt leaks_tgt) *)
(*       (MEM_SRC: FORGET_MEMORY_TODO) *)
(*       (MEM_TGT: FORGET_MEMORY_TODO) *)
(*   : exists invst1 invmem1, *)
(*     <<STATE: InvState.Rel.sem conf_src conf_tgt st1_src st1_tgt invst1 invmem1 *)
(*                               (ForgetMemory.t def_memory_src def_memory_tgt *)
(*                                               (Forget.t def_src def_tgt leaks_src leaks_tgt inv0)) >> /\ *)
(*     <<MEM: InvMem.Rel.sem conf_src conf_tgt st1_src.(Mem) st1_tgt.(Mem) invmem1>> /\ *)
(*     <<MEMLE: InvMem.Rel.le invmem0 invmem1>>. *)
(* Proof. *)


  
(* Admitted. *)


(* Definition FORGET_MEMORY_CALL_TODO: Prop. Admitted. (* TODO *) *)

(* Lemma postcond_call_forget_sound *)
(*       conf_src st0_src st1_src def_src leaks_src *)
(*       conf_tgt st0_tgt st1_tgt def_tgt leaks_tgt *)
(*       invst0 invmem0 inv0 *)
(*       (STATE: InvState.Rel.sem conf_src conf_tgt st0_src st0_tgt invst0 invmem0 inv0) *)
(*       (MEM: InvMem.Rel.sem conf_src conf_tgt st0_src.(Mem) st0_tgt.(Mem) invmem0) *)
(*       (STATE_SRC: state_equiv_except def_src st0_src st1_src) *)
(*       (STATE_TGT: state_equiv_except def_tgt st0_tgt st1_tgt) *)
(*       (UNIQUE_SRC: unique_preserved_except conf_src invst0.(InvState.Rel.src) inv0.(Invariant.src) st1_src def_src leaks_src) *)
(*       (UNIQUE_TGT: unique_preserved_except conf_tgt invst0.(InvState.Rel.tgt) inv0.(Invariant.tgt) st1_tgt def_tgt leaks_tgt) *)
(*       (MEM_SRC: FORGET_MEMORY_CALL_TODO) *)
(*       (MEM_TGT: FORGET_MEMORY_CALL_TODO) *)
(*   : exists invst1 invmem1, *)
(*     <<STATE: InvState.Rel.sem conf_src conf_tgt st1_src st1_tgt invst1 invmem1 *)
(*                               (ForgetMemoryCall.t (Forget.t def_src def_tgt leaks_src leaks_tgt inv0)) >> /\ *)
(*     <<MEM: InvMem.Rel.sem conf_src conf_tgt st1_src.(Mem) st1_tgt.(Mem) invmem1>> /\ *)
(*     <<MEMLE: InvMem.Rel.le invmem0 invmem1>>. *)
(* Proof. *)
(* Admitted. *)
