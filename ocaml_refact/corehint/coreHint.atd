type scope = [ Source | Target ] <ocaml repr="classic">

type position_phinode = {
  prev_block_name : string;
}

type position_command = {
  index : int;
  register_name : string;
}

(* Position of an instruction is phinode or register *)
type instr_index = [
  | Phinode of position_phinode
  | Command of position_command
  ] <ocaml repr="classic">

type position = {
  scope : scope;
  block_name : string;
  instr_index : instr_index;
}

(* If tag of register is one of Physical, Previous, and Ghost *)
type tag = [ Physical | Previous | Ghost ] <ocaml repr="classic">

type register = {
  name : string; (* identifier of a register *)
  tag : tag;     (* indicates whether this register is physical or previous or ghost *)
}

(* integer type of bitsize *)
type int_type = [ IntType of int ] <ocaml repr="classic">

(* float type *)
(* http://llvm.org/docs/LangRef.html#floating-point-types *)
(* http://llvm.org/docs/doxygen/html/classllvm_1_1APFloat.html *)
type float_type = [ 
    | HalfType (* equivalent to Llvm.APFloat.Semantics.IEEEhalf in LLVM ocaml binding *)
               (* no matching type in Vellvm *)
    | FloatType (* equivalent to Llvm.APFloat.Semantics.IEEEsingle in LLVM ocaml binding *)
                (* equivalent to Syntax.LLVMsyntax.Coq_fp_float in Vellvm *)
    | DoubleType (* equivalent to Llvm.APFloat.Semantics.IEEEdouble in LLVM ocaml binding *)
                 (* equivalent to Syntax.LLVMsyntax.Coq_fp_double in Vellvm *)
    | FP128Type (* equivalent to Llvm.APFloat.Semantics.IEEEquad in LLVM ocaml binding*)
                (* equivalent to Syntax.LLVMsyntax.Coq_fp_fp128 in Vellvm*)
    | PPC_FP128Type (* equivalent to Llvm.APFloat.Semantics.PPCDoubleDouble in LLVM ocaml binding *)
                    (* equivalent to Syntax.LLVMsyntax.Coq_fp_ppc_fp128 in Vellvm*)
    | X86_FP80Type (* equivalent to Llvm.APFloat.Semantics.X87DoubleExternded in LLVM ocaml binding *)
                   (* equivalent to Syntax.LLVMsyntax.Coq_fp_x86_fp80 in Vellvm*)
    ] <ocaml repr="classic">

type value_type = [ IntValueType of int_type | FloatValueType of float_type | NamedType of string | PtrType of (int * value_type) ] <ocaml repr="classic">

type const_int = {
  int_value : int;
  int_type : int_type;
}

type const_float = {
  float_value : float;
  float_type : float_type;
}

type constant = [ ConstInt of const_int | ConstFloat of const_float ] <ocaml repr="classic">

type value = [ Id of register | ConstVal of constant ] <ocaml repr="classic">

type size = [ Size of int ] <ocaml repr="classic">

type bop = [ | BopAdd | BopSub | BopMul | BopUdiv 
             | BopSdiv | BopUrem | BopSrem | BopShl 
             | BopLshr | BopAshr | BopAnd | BopOr 
             | BopXor | BopFadd | BopFsub | BopFmul 
             | BopFdiv | BopFrem ] <ocaml repr="classic">

type binary_operator = {
  opcode : bop;
  operandtype : value_type;
  operand1 : value;
  operand2 : value;
}

type load_inst = {
  pointertype : value_type;
  valtype : value_type;
  ptrvalue : value;
  align : int;
}

type instruction = [ 
  | BinaryOp of binary_operator
  | LoadInst of load_inst
] <ocaml repr="classic">

type expr = [
  | Var of register
  | Rhs of (register * scope)
  | Const of constant
  | Insn of instruction
] <ocaml repr="classic">


(*****************************************)
(*              Propagates               *)
(*****************************************)

type propagate_lessdef = {
  lhs : expr;
  rhs : expr;
  scope : scope;
}

type propagate_noalias = {
  lhs : register;
  rhs : register;
  scope : scope;
}

type propagate_alloca = {
  p : register;
  scope : scope;
}

type propagate_object = [
  | Lessdef of propagate_lessdef
  | Noalias of propagate_noalias
  | Alloca of propagate_alloca
  | Maydiff of register
  ] <ocaml repr="classic">

type propagate_range = [
  | Bounds of (position * position)
  | Global
  ] <ocaml repr="classic">

type propagate = {
  propagate : propagate_object;
  propagate_range : propagate_range;
}

(*****************************************)
(*             Inference rules           *)
(*****************************************)

type add_associative = {
  x : register;
  y : register;
  z : register;
  c1 : const_int;
  c2 : const_int;
  c3 : const_int;
  sz : size;
}

type add_sub = {
  minusy : register;
  z : register;
  x : value;
  y : value;
  sz : size;
}

type add_commutative = {
  z : register;
  x : value;
  y : value;
  sz : size;
}

type add_shift = {
  y : register;
  v : value;
  sz : size;
}

type add_signbit = {
  x : register;
  e1 : value;
  e2 : value;
  sz : size;
}

type transitivity = {
  e1 : expr;
  e2 : expr;
  e3 : expr;
}

type transitivity_tgt = {
  e1 : expr;
  e2 : expr;
  e3 : expr;
}

type noalias_global_alloca = {
  x : register;
  y : register;
}

type transitivity_pointer_lhs = {
  p : value;
  q : value;
  v : value;
  loadq : expr;
}

type transitivity_pointer_rhs = {
  p : value;
  q : value;
  v : value;
  loadp : expr;
}

type bop_both_src_left = {
  b : bop;
  x : value;
  y : value;
  z : value;
  sz : size;
}

type bop_both_src_right = {
  b : bop;
  x : value;
  y : value;
  z : value;
  sz : size;
}

type bop_both_tgt_left = {
  b : bop;
  x : value;
  y : value;
  z : value;
  sz : size;
}

type bop_both_tgt_right = {
  b : bop;
  x : value;
  y : value;
  z : value;
  sz : size;
}

type intro_eq = {
  e : expr;
  g : register;
}

type replace_rhs = {
  x : register;
  y : value;
  e1 : expr;
  e2 : expr;
  e2' : expr;
}

type intro_ghost = {
  x : value;
  g : register;
}

type add_onebit = {
  z : register;
  x : value;
  y : value;
}

type add_zext_bool = {
  x : register;
  y : register;
  b : value;
  c : const_int;
  cprime : const_int;
  sz : size;
}

type add_const_not = {
  z : register;
  y : register;
  x : value;
  c1 : const_int;
  c2 : const_int;
  sz : size;
}

type add_mask = {
  z : register;
  y : register;
  yprime : register;
  x : value;
  c1 : const_int;
  c2 : const_int;
  sz : size;
}

type add_select_zero = {
  z : register;
  x : register;
  y : register;
  c : value;
  n : value;
  a : value;
  sz : size;
}

type add_select_zero2 = {
  z : register;
  x : register;
  y : register;
  c : value;
  n : value;
  a : value;
  sz : size;
}

type add_dist_sub = {
  z : register;
  minusx : register;
  minusy : value;
  w : register;
  x : value;
  y : value;
  sz : size;
}

type gepzero = {
  v : value;
  vprime : value;
  gepinst : expr;
}

type bitcastptr = {
  v : value;
  vprime : value;
  bitcastinst : expr;
}

type mul_add_distributive = {
  z : register;
  x : register;
  y : register;
  w : register;
}

type neg_val = {
  c1 : const_int;
  c2 : const_int;
  sz : size;
}

type noalias_global_alloca = {
  x : register;
  y : register;
}

type noalias_lessthan = {
  x : value;
  y : value;
  xprime : value;
  yprime : value;
}

type noalias_global_global = {
  x : register;
  y : register;
}

type sub_add = {
  z : register;
  my : value;
  x : register;
  y : value;
  sz : size;
}

type sub_mone = {
  z : register;
  x : value;
  sz : size;
}

type sub_const_not = {
  z : register;
  y : register;
  x : value;
  c1 : const_int;
  c2 : const_int;
  sz : size;
}

type sub_remove = {
  z : register;
  y : register;
  a : value;
  b : value;
  sz : size;
}

type sub_onebit = {
  z : register;
  x : value;
  y : value;
}

type sub_const_add = {
  z : register;
  y : register;
  x : value;
  c1 : const_int;
  c2 : const_int;
  c3 : const_int;
  sz : size;
}

type sub_sdiv = {
  z : register;
  y : register;
  x : value;
  c : const_int;
  cprime : const_int;
  sz : size;
}

type sub_shl = {
  z : register;
  x : value;
  y : register;
  mx : value;
  a : value;
  sz : size;
}

type mul_bool = {
  z :register;
  x :register;
  y :register;
}

type mul_mone = {
  z : register;
  x : value;
  sz : size;
}

type mul_neg = {
  z : register;
  mx : value;
  my : value;
  x : value;
  y : value;
  sz : size;
}

type mul_commutative = {
  z : register;
  x : value;
  y : value;
  sz : size;
}

type mul_shl = {
  z : register;
  y : register;
  x : value;
  a : value;
  sz : size;
}

type sdiv_mone = {
  z : register;
  x : value;
  sz : size;
}

type and_de_morgan = {
  z : register;
  x : register;
  y : register;
  zprime : register;
  a : value;
  b : value;
  sz : size;
}

type rem_neg = {
  z : register;
  my : value;
  x : value;
  y : value;
  sz : size;
}

type sdiv_sub_srem = {
  z : register;
  b : register;
  a : register;
  x : value;
  y : value;
  sz : size;
}

type udiv_sub_urem = {
  z : register;
  b : register;
  a : register;
  x : value;
  y : value;
  sz : size;
}

type infrule = [
  | AddAssociative of add_associative
  | AddSub of add_sub
  | AddCommutative of add_commutative
  | AddShift of add_shift
  | AddSignbit of add_signbit
  | AddOnebit of add_onebit
  | AddZextBool of add_zext_bool
  | AddConstNot of add_const_not
  | AddMask of add_mask
  | AddSelectZero of add_select_zero
  | AddSelectZero2 of add_select_zero2
  | AddDistSub of add_dist_sub
  | AndDeMorgan of and_de_morgan
  | Bitcastptr of bitcastptr
  | Gepzero of gepzero
  | MulAddDistributive of mul_add_distributive
  | NegVal of neg_val
  | SubMone of sub_mone
  | SubAdd of sub_add
  | SubConstNot of sub_const_not
  | SubRemove of sub_remove
  | SubOnebit of sub_onebit
  | SubConstAdd of sub_const_add
  | SubSdiv of sub_sdiv
  | SubShl of sub_shl
  | MulBool of mul_bool
  | MulMone of mul_mone
  | MulNeg of mul_neg
  | MulCommutative of mul_commutative
  | MulShl of mul_shl
  | NoaliasGlobalAlloca of noalias_global_alloca
  | NoaliasGlobalGlobal of noalias_global_global
  | NoaliasLessthan of noalias_lessthan
  | RemNeg of rem_neg
  | ReplaceRhs of replace_rhs
  | SdivMone of sdiv_mone
  | SdivSubSrem of sdiv_sub_srem
  | UdivSubUrem of udiv_sub_urem
  | Transitivity of transitivity
  | TransitivityTgt of transitivity_tgt
  | TransitivityPointerLhs of transitivity_pointer_lhs
  | TransitivityPointerRhs of transitivity_pointer_rhs
  | BopBothSrcLeft of bop_both_src_left
  | BopBothSrcRight of bop_both_src_right
  | BopBothTgtLeft of bop_both_tgt_left
  | BopBothTgtRight of bop_both_tgt_right
  | IntroEq of intro_eq
  | ReplaceRhs of replace_rhs
  | IntroGhost of intro_ghost
  ] <ocaml repr="classic">

type hint_command = [
  | Propagate of propagate
  | Infrule of (position * infrule)
  ] <ocaml repr="classic">

type hints = {
  module_id : string;
  function_id : string;
  opt_name : string;

  nop_positions: position list; (* insert after position *)

  commands : hint_command list;
}
